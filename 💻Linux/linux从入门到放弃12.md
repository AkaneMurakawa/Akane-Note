---
title: 继电器与深入了解二进制
date: 2017-9-5 13:47:00
categories: Linux
comments: true
---
# 继电器与深入了解二进制

大家好，欢迎大家来阅读我的文章。

声明部分内容来自[软件那些事儿](http://www.ximalaya.com/46905980/sound/28154721/)，这是我很喜欢的一个电台，里面讲述了IT界的历史，我觉得在如今去了解过去的历史是一件很有趣的事情，这样对我们理解一些东西可能会有帮助吧。我对历史了解甚

少，很感谢栋哥给我带来这些过去的历史故事，对我来说我读这些故事更能去思考一些东西， 比看书的时候全是知识点会好玩很多。因此我也尽量去了解更多的历史并写在文章里。这里我主要是想说二

进制，但是继电器应该也说一下，所以就引用了栋哥的这篇文章[83. 电脑原理01-从继电器开始](http://www.ximalaya.com/46905980/sound/28154721/),建立大家去读一下原文写的真都很好很有趣。好了，那么我们来说一下。



我们都知道计算机只识别二进制，从我们的理解里二进制是0或者1，我听过另一个说法是有电和没电。那么这个二进制在计算机中又是如何表示的呢？从物理上来说，这里的话就是继电器，不过现在都

用晶体管了，在我们的CPU上就拥有很多这些晶体管。（晶体管（transistor）是一种固体半导体器件，具有检波、整流、放大、开关、稳压、信号调制等多种功能。晶体管作为一种可变电流开关，能够

基于输入电压控制输出电流。与普通机械开关（如Relay、switch）不同，晶体管利用电讯号来控制自身的开合，而且开关速度可以非常快，实验室中的切换速度可达100GHz以上。严格意义上讲，晶体管

泛指一切以半导体材料为基础的单一元件，包括各种半导体材料制成的二极管、三极管、场效应管、可控硅等。晶体管有时多指晶体三极管。）

### 继电器
> [转]如果大家对计算机的历史有理解的话，第一台计算机再1930年代被制造出来，里面的设备就是继电器，这台计算机的名字叫机械式继电器计算机，这台计算机通过继电器里面的弹簧片的接通和断开来
>
> 表示二进制的0和1，后来由于继电器的性能不能保障，因为里面有弹簧片，弹簧片这种东西，弹多了，就失效了，而且使用的能量也太多了。继电器中有弹簧，我们知道，弹簧的速度是不够快的，最快
>
> 的弹簧片，需要1/100秒改变一下状态，而且，弹簧片不可靠，因此，并没有大规模的应用。但是德国的科学家朱塞就是使用继电器制造出了一台全自动的计算机，速度肯定不快，但是已经具有现在计算
>
> 机的一些特征了，能够计算浮点数，二进制计算等等。后来才使用电子管代替了继电器，后来又用晶体管代替了电子管，但是，基本的原理并没有发生翻天覆地的变化。
>
> 今天我们使用的晶体管计算机，速度更快，能耗更低，也更便宜。但是，里面的工作原理和继电器的计算机并没有任何区别，今天的一个8位的加法器需要144个晶体管，同样，当年构造一个8位的加法
>
> 器，需要144个继电器。只是现在科技发达了，由于集成电路的突飞猛进，144个晶体管，尤其是现在intel有10纳米的工艺，144个晶体管可能需要用电子显微镜才能看清楚。但是继电器的话，144个继电
>
> 器，可能得一大坨。但是，我们要知道，里面的原理是一模一样的。
>
> 继电器。为什么需要继电器呢？电线有个特征，电阻。就是随着距离的增加，电压会越来越小。在电线上传递的信号逐渐的就没有了。比如说，从北京发信号到上海，可能电线到了济南，就没电了，这时
>
> 候怎么办呢？有一个办法，在济南的荒郊野外盖一个小屋子，丢一个人进去，他负责两件事情，把信号记录下来，然后再从济南发一份到徐州，然后徐州再发一份到上海。沿途有2个倒霉蛋在荒郊野外，
>
> 负责把信号增强，这个工作应该挺无聊。继电器的工作就是代替这两个倒霉蛋的工作的，通过电磁铁的原理，从北京传来的信号，到达济南的电流，驱动一个电磁铁，然后这个电磁铁在拉动金属杆，然后
>
> 这个被拉动的金属杆，恰好是济南到徐州的一个电路的开关，这样，北京过来的，比较虚弱的电流，在济南经过继电器电路，一个加强的信号又被放大，然后到了徐州，徐州也有一个相同的继电器，然后
>
> 信号又被放大，然后到了上海。这就是继电器在电报中的工作原理。不过呢，还是得看图，说不清楚。电路图在下面。![](images/继电器.png)
>
> 可能有些同学觉得，这个继电器太简单了，因为他只能做一件事情啊，就是传递信号。是的，他确实非常简单，就是一个弹簧片，外加一根铁棍，还有一个线圈，实现的功能看起来也没什么大不了的。但
>
> 是，毫无疑问的是，在任何博物馆里，尤其是电学的博物馆里，一定有一个地方是给继电器这个小东西留着的，因为他看起来不算什么神奇的东西，但是，把几个继电器按照不同的方法连接起来，就可以
>
> 完成更加神器的东西。



### 二进制
上面引用说的就是在我们的计算机中0和1在物理上是怎么表示的，我一直觉得软硬件都懂得是一件很好的事情。那我们开始说二进制，作为一个程序员的话对于二进制肯定要了解的。在之前我们先来看

一个东西
<img src="images/算盘.jpg" width="50%"/>

没错，这就是我们古代时候用的算盘，分为上珠和下珠，上面一个代表五，下面一个代表一。那当我想表示十一的时候怎么办，这个时候就在左边新增一个代表十，右边放一个。那一百零一呢？同样在右

数第三个下珠一个代表100。这里就有一个进制的概念，就是满十进一，而二进制同样我们知道是满二进一，但只是我们平常对二进制的理解，其实二进制是很有规律的。首先我们看十进制。

十进制第一位就是10^0，那我们得出结论就是十进制就是以10为底，那我们同理可以画出二进制的，画的丑见谅。
![](images/二进制01.jpg)

思考一下，那十进制的50对应的二进制是什么？

好，我来公布一下：首先二进制从右边开始往左，1代表十进制分别为：1-2-4-8 16-32-64-128（2^n这个就是我们说的权，2就是基数）

那50对应的按权展开就是0011 0010。（0+0+32+16+0+0+2+0）

这个时候你会看到，为什么我在前面会多加了两个零。可能有一些比较了解的朋友知道，在二进制中，高位如果是1代表负数，而0代表正数。而在计算机中以位（bit）为单位，但是位太小了，于是用字

节表示（一个字节byte=8位）。所以这样50就转换成你上面看到的那样了。我们老师说的可能是下面这种：
![](images/二进制02.png)

当我们用除二取余法的时候，每次除2，就是找到对应的权值，比如说这里的89，我们知道2^6=32，2^7=64,所以说非符号位最大权值是2^7，那89就是01\*\* \*\*\*\*。基于这个思想，那我们就不用每次都用除二取

余法了， 我们记住最简单的几个权值：1-2-4-8 16-32-64-128。那89就是0101 1001 (0+64+0+16 8+0+0+1=89)。

如果是二进制转换十进制那更简单了。比如0000 1010就是(8+2=10)。

### 负数与补码由来
十进制中可以表示负数，同样二进制也可以，这里我以四位来说。我们不废话，先看图。
![](images/二进制02.jpg)

我们可以把二进制画成一个时钟，因为用4位表示的个数正负是一样的都是8个，所以右边的给了正数，左边的分一半给负数。于是规定了0开头代表正数，而1代表负数，这个称为符号位。这个时候你就

有疑问了，**那这-1对应的不应该是1001**，你不是告诉我说是权值吗，难道错了。并没有，首先我告诉你一个规律：-**1对应的反码就是0000，而这个0000加1对应的就是-1的相反数1**。是不是感觉其他的数

都是一样。在数学中：-1+1=0,-10+10=0。我们称两个数互为相反数，互补。二进制中就称之为补码，记住上面的规律。**补码=反码+1，而反码就是原码中的0<->1互换啦**。在运行程序的时候，我们都是

以补码的形式。



所以你知道-1怎么表示了吧。

首先-1的补码是1（0001），然后（补码-1）得到-1的反码是0000，那原码就是1111啦。真棒是吧。

当有人问你的时候，在四位中，二进制正数最大最小是多少？负数最大最小是多少？

你就可以回答是：0000和01111， 1111和1000。

我们还发现，如果是-1减去1的话，那就是-2了。

1111-0001=1110。

那这样我们很快就知道-6的是什么了，就是-1-5=-6。还记得权值吗？

没错，1111-0101=1010。

这样我们就不用通过补码-1取反码得到负数对应的表示了。



**请记住，负数最大的都是每一个上都是1。而正数是符号位0，其他都是1。**

我在网上找了一个好的二进制循环编码盘，大家可以看看，比我画的好很多。黑色代表1
<img src="images/二进制03.jpg" width="30%"/>



### 十六进制

首先做个测试，请问这个代表十进制的多少：10101100 01011001？

是不是感觉眼睛都看花了，这就是我们要介绍十六进制的原因。十六的进制很显然也是满16进一，16为基数。但是这不是我们学习的目的，十六进制的用途就是用来简化二进制。

十六进制数字与二进制数字的对应关系如下：
0000 -> 0 0100 -> 4 1000 -> 8 1100 -> C
0001 -> 1 0101 -> 5 1001 -> 9 1101 -> D
0010 -> 2 0110 -> 6 1010 -> A 1110 -> E
0011 -> 3 0111 -> 7 1011 -> B 1111 -> F

从第十位1010开始就用字母表示了。F对应的就是15。0-9对应0-9，A-F对应10-15

那上面的问题我们可以简化成:首先十六进制表示为AE59。如果换算成十进制就是：9\*16^0+5\*16^1+E\*16^2+A\*16^3=?

当然我这里就不算了，因为十六进制的设计就是用来简化二进制就达到目的。他也有上面那种转成为二进制，十进制的方法。但我们这里不去追究。

如果学过ps的同学可能有了解过三颜色下面有关#号的代表的就是十六进制了。

### (移)位运算符
最后补充一个，位运算符，不是我们物理那个位移。移位运算符在程序设计中，是位操作运算符的一种，就是我们上面说的几位的位。移位运算符可以在二进制的基础上对数字进行平移。按照平移的方向

和填充数字的规则分为三种：

* <<（左移位运算）
* \>\>（数学右移位）
* \>\>\>（逻辑位右移）
用途：文字的编码
我们在学的小数中就有这个位移的思想，比如3.14小数点右移动一位就是31.4(3.14\*10^1),向左移动一位就是0.314(3.14\*10^-1)。
同理，移位运算符也有类似的规则。\>\>\>有些也称为无符号右移，之所以会说逻辑位右移，是因为它符号我们的逻辑。
我们来看一下下面的伪代码

#### 区别
```
数学右移位 >> 

	n =      00000000 00000000 00000000 00110010  50
	m = n>>1 000000000 00000000 00000000 0011001  25
	k = n>>2 0000000000 00000000 00000000 001100  12

	n =      11111111 11111111 11111111 11001110  -50 
	m = n>>1 111111111 11111111 11111111 1100111  -25
	k = n>>2 1111111111 11111111 11111111 110011  -13 

逻辑右移位 >>>

	n =       00000000 00000000 00000000 00110010  50
	m = n>>>1 000000000 00000000 00000000 0011001  25
	k = n>>>2 0000000000 00000000 00000000 001100  12

	n =       11111111 11111111 11111111 11001110  -50 
	m = n>>>1 011111111 11111111 11111111 1100111  
	k = n>>>2 0011111111 11111111 11111111 110011   

左移位运算	
n  =      00000000 00000000 00000000 00110010  50
	m = n<<1  0000000 00000000 00000000 001100100  100   
	k = n<<2  000000 00000000 00000000 0011001000  200
```
总结：
* 数学右移位\>\>: 其结果满足数学规律, 整除向小方向取整，负数移位，高位补1 结果还是负数。
* 逻辑右移位\>\>\>: 无论正负高位都补0。
* 左移位运算: 溢出位补0。
二进制的移位有时候可以做优化运算，因为
n<< 3 比起 n\*8会快。
这次写的太长了。就到这里先吧。在二进制运算符中，还有三个重要的运算符留着下一次讲：取反~,与&，或|。
结合移位运算符，我们就可以进行文字的编码。就是我们通常说的GBK，UTF-8，我们在出现乱码的时候就是编码和解码不一致导致的，让我们走进文字的编码世界去探个究竟吧。这一期先到这里，下一次我们说一下文字的编码，Unicode和UTF-8。
