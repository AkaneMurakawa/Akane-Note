---
title: C语言-变量和关键字
date: 2018-09-12 03:55:13
categories: C语言编程
toc: true
comments: true
---
# 第六章 变量和关键字



在编程中我们要经常用到的就是变量，而变量如果不小心使用很可能给我们带来非常大的麻烦。我们这次研究的是变量和被C语言中一些关键字修饰的变量，看看这些有什么作用。要深入理解一个变量，我们就要从三个方面了解它：<strong>存储位置，作用域，生命周期</strong>。请记住，当你要学一个东西从这三个方面去研究能够帮助你更好的理解。比如：我在Java学习中，其中的cookie和session的生命周期就是一个非常关键的地方，这也是决定了我们应该怎么使用。

所以我们研究的目的，是为了更好的使用。



### auto自动变量

存储位置： 栈区--空间由系统自动分配和释放
作用域：局部变量
生命周期：有效时间所在的{}



### 全局变量

存储位置： 静态存储区
作用域：在函数外
生命周期：
注意： 全局变量系统自动初始化为0，建议手动。



### const修饰符

类型修饰符：const 常量修饰符。
使用地方：const的使用， 可读不可改。
注意：const修饰的必须是个常量。
```c
//const int a;
    //a = 12; //错误(活动)  E0137   表达式必须是可修改的左值.
    // 说明a是一个常量
    // const int a = 12; // 合法
    // const int arr[2] = {12, 2}; // 合法
```

<strong>那么如果const修饰的是一个指针会怎么样呢？我们来研究一下const int&#42; p 和 int&#42; const 的区别</strong>
```c
    //int a = 12;
    //int b = 13;
    //int* const p = &amp;a;
    //*p = 32;  // 合法
    //p = &amp;b; // 错误

    //int a = 12;
    //int b = 13;
    //const int* p = &amp;a;
    //*p = 32;  // 错误
    //p = &amp;b; // 合法

    //const修饰指针
    // 1.右侧*p，*p常量， p非常量                const int* p = &amp;a;
    // 2.在*p之间，*p可以修改，p不可以修改。      int* const p = &amp;a;
    总结：修饰的是谁，谁就不可以修改，否则报错。修饰的是*p则*p不可以被修改，
                                            修饰的是p则p不可以被修改。
```



### static静态变量

存储： 静态存储区，全局变量也是
生命周期： 与程序共存亡
作用域： 局部变量。可以从存储的位置不同去理解。
初始化，要用常量，不能用变量。

<strong>注意1：static的生命周期是与程序共存亡</strong>
我们来测试一下
```c
void fun1()
{
    // 每次执行后不释放，与程序共存亡
    static int d = 12;
    d += 1;
    printf("%d\n", d);
}
void fun2()
{
    // 每次执行完释放
    int d = 12;
    d += 1;
    printf("%d\n", d);
}
我们通过多次调用函数来看看里面的变量的值
//  fun1();
//  fun1();
//  fun1();
//  fun2();
//  fun2();
//  fun2();
//  //结果：
//  //  13
//  //  14
//  //  15
//  //  13
//  //  13
//  //  13
```

我们在书上也可能会经常看到这个东西，那时候我还不太理解，后来对生命周期理解更深的时候，慢慢就理解。<strong>static在编译的时候分配空间，而auto自动变量在程序运行的时候。</strong>

<strong>我们来测试一下：static在编译的时候分配空间，而auto自动变量在程序运行的时候</strong>
```
    int b = 12;
    static int c = b; // 错误 初始化，要用常量，不能用变量。
    解释： 报错的结果的告诉了我们，b还没有分配，也就是没有值，我们可以通过debug的时候
    测试一下，看看没有运行到语句的时候，c和b的值，你很快就会恍然大悟了。因此，我们不能
    把b的值赋给c。
```