# JVM - 调优

## 调优前基础概念

1. 吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）
2. 响应时间：STW越短，响应时间越好

所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量...



对比：

吞吐量：科学计算，数据挖掘，thrput。（吞吐量优先的一般：PS + PO）

响应时间：网站 GUI API （1.8 G1）



### 什么是调优？

1. 根据需求进行JVM规划和预调优
2. 优化运行JVM运行环境（慢，卡顿）
3. 解决JVM运行过程中出现的各种问题(JVM调优 != 解决OOM，但是面试官问你调优或许想听的就是你解决OOM问题)



### 调优 - 从规划开始

- 调优，从业务场景开始，没有业务场景的调优都是耍流氓
- 无监控（压力测试，能看到结果），不调优
- 步骤：
  1. 熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）
     1. 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）
     2. 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS]
  2. 选择回收器组合
  3. 计算内存需求（经验值 1.5G 16G）
  4. 选定CPU（越高越好）
  5. 设定年代大小、升级年龄
  6. 设定日志参数
     1. -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause（**说明：循环使用日志，有五个日志文件，每个文件20M，需要设置三个参数**）
     2. 或者每天产生一个日志文件
  7. 观察日志情况



## JVM规划案例

### 案例1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？

> 这个问题比较业余，因为很多不同的服务器配置都能支撑(1.5G 16G)
>
> 1小时360000集中时间段， 100个订单/秒，（找一小时内的高峰期，1000订单/秒）
>
> 经验值，
>
> 非要计算：一个订单产生需要多少内存？512K * 1000 = 500M内存
>
> 专业一点儿问法：要求响应时间100ms
>
> 压测！



### 案例2：12306遭遇春节大规模抢票应该如何支撑？

> 12306应该是中国并发量最大的秒杀网站：
>
> 号称并发量100W最高
>
> CDN -> LVS -> NGINX -> 业务系统 -> 每台机器1W并发（10K经典问题） 100台机器
>
> 普通电商订单 -> 下单 ->订单系统（IO）减库存 ->等待用户付款
>
> 12306的一种可能的模型： 下单 -> 减库存 和 订单(redis kafka) 同时异步进行 ->等付款
>
> 减库存最后还会把压力压到一台服务器
>
> 可以做分布式本地库存 + 单独服务器做库存均衡
>
> 大流量的处理方法：分而治之



怎么得到一个事务会消耗多少内存？

> 1. 弄台机器，看能承受多少TPS？是不是达到目标？扩容或调优，让它达到
> 2. 用压测来确定



### 案例3：线程池使用不当

> 频繁产生很多新的对象



### 案例4：大批量的查询或大批量的打印日志

> 查询未加限制条件，导致全表扫描，产生很多新对象。
>
> 
>
> 还有一种情况是，在打印日志的时候，使用log4j2打印了太多的info信息，有些对象内容中可能包含二进制、base64
>
> 当用户请求特别频繁的时候，会导致打印的内容特别多，频繁的GC，CPU占用高
>
> 



### 案例5：Lambda表达式使用不当，方法区溢出

> ```java
> public class LambdaGC {
>     public static void main(String[] args) {
>         for(;;) {
>             I i = C::n;
>         }
>     }
> 
>     public static interface I {
>         void m();
>     }
> 
>     public static class C {
>         static void n() {
>             System.out.println("hello");
>         }
>     }
> }
> ```

### 案例6：栈溢出问题

> 栈溢出：StackOverflow，递归或嵌套方法太多导致
>
> -Xss设定大小



### 案例7：重写finalize引发频繁GC

> 小米云，HBase同步系统，系统通过nginx访问超时报警，最后排查，C++程序员写Java程序时重写了finalize，引发频繁GC问题 
>
> 为什么C++程序员会重写finalize？因为C++是手动释放内存的（new delete）
>
> 当在finalize耗时比较长（200ms），会导致释放内存慢。



### 案例8：频繁GC

> 如果有一个系统，内存一直消耗不超过10%，但是观察GC日志，发现FGC总是频繁产生，会是什么引起的？
>
> 答：手动调用了 System.gc() 
>
> 可以设置-XX:+DisableExplictGC System.gc()不管用 ，FGC



## 优化环境

### 案例1：50万PV，内存升级问题

有一个50万PV的资料类网站（从磁盘提取文档到内存）原服务器32位，1.5G 的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为64位，16G 的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了

> 分析：
>
> 1. 为什么原网站慢? 很多用户浏览数据，很多数据load到内存，内存不足，频繁GC，STW长，响应时间变慢
> 2. 为什么会更卡顿？ **内存越大，FGC时间越长**
> 3. 咋办？ PS -> PN + CMS 或者 G1



### 案例2：系统CPU经常100%，如何调优？(**面试高频**) 

> 分析：
>
> 1. CPU100%那么一定有线程在占用系统资源
> 2. 找出哪个进程cpu高（top）
> 3. 该进程中的哪个线程cpu高（top -Hp）
> 4. 导出该线程的堆栈 (jstack)
> 5. 查找哪个方法（栈帧）消耗时间 (jstack)
> 6. 工作线程占比高 | 垃圾回收线程占比高



### 案例3：系统内存飙高，如何查找问题？（**面试高频**）

> 分析：
>
> 1. 导出堆内存 (jmap)
> 2. 分析 (jhat jvisualvm mat jprofiler ... )


