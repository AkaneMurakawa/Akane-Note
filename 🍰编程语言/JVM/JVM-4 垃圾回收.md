# JVM - 垃圾回收

## 如何判断对象的死亡？

- 引用计数器，为0（不能解决循环引用问题）
- 可达性分析算法（GC Roots不可达）



### 可达性分析算法

将“**GC Roots**”对象作为起点，从这些节点开始向下搜索引用的对象，搜索走过的路径被称为引用链（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。引用链可达标记为非垃圾对象，引用链不可达是垃圾对象。



#### GC Roots根节点

虚拟栈(即线程栈)的本地变量、静态变量、常量池、本地方法栈(native)的变量等等。 



## GC算法

- 标记-清除（Mark-Sweep）

- 复制算法（Copying）
- 标记-压缩（标记整理）（Mark-Compact）



### 1、标记清除算法(Mark-Sweep)

说明：先把内存区域中的对象进行标记，标记哪些属于可回收，然后将其清理掉。



分析：

- 算法相对简单
- 存活对象较多时效率高
- 两遍扫描、效率偏低
- 由于分配内存的时候需要连续的空间，那么清理这些空间的时候，就会造成不再可用，形成垃圾碎片，浪费空间

![标记清除.jpg](images/标记清除.jpg)



### 2、复制算法（Copying）

说明：将内存分为两个区域，先在一个区域存储，然后将可用的对象移到另一个区域，清理掉垃圾区域。



分析：

- 适用于存活对象较少的情况
- 只扫描一次，效率提高，没有碎片
- 空间浪费
- 移动复制对象，需要调整对象引用

![复制算法.jpg](images/复制算法.jpg)



### 3、标记-压缩（标记整理）（Mark-Compact）

说明：标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的**对象都压缩到一端**，再清理掉端边界以外的内存区域。



分析：

- 没有碎片，方便对象分配
- 不会浪费空间
- 扫描两次
- 需要移动对象，效率偏低



![标记压缩.jpg](images/标记压缩.jpg)



## JVM内存分代算法

将内存空间分配几个区域，然后每个区域选择合适的垃圾收集算法(前面说的123，标记清除、复制算法、标记压缩算法)

注：

> 除Epsilon、ZGC、Shenandoah之外的GC都是使用逻辑分代模型
>
> G1是逻辑分代，物理不分代；除此之外，逻辑分代，物理分代



### 结论

- 新生代大量死去，少量存活，适合复制算法

- 老年代存活率高，回收较少，适合标记清除或标记压缩



### 一个对象从出生到消亡的过程

![一个对象的出生到消亡.jpg](images/一个对象的出生到消亡.jpg)





堆内存逻辑分区

例如：

复制算法会把内存分为两个区域（即两个survivor空间：from和to）。当进行一次minor gc时（既年轻代的gc），minor gc是串行的，eden空间如果没有被gc root引用的会被回收，**而依然存活的会被移动到from空间中**，如果from空间在minor gc时对象依旧可以存活，就会对该对象年龄+1，当年龄达到一定数值时会直接放入老年代，没有达到年龄的存活对象会被复制到to中。这时from和eden空间已经被清空，虚拟机会交换from和to的空间，空的from变成to，to的变成from，保证了to是空的，minor gc会不断重复这样的工作，直到to彻底被填满，这时会将对象移动到老年代。



## GC概念

https://kuaibao.qq.com/s/20190228A0656E00?refer=spider



栈上分配

- 线程私有小对象
- 无逃逸
- 支持标量替换
- 无需调整



线程本地分配TLAB(Thread Local Allocation Buffer)

- 占用eden，默认1%
- 多线程的时候不用竞争eden就可以申请空间，提高效率
- 小对象
- 无需调整



老年代

- 大对象

eden