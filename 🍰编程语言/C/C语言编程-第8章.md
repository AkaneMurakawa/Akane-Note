---
title: C语言编程-大端模式和小端模式与预处理和宏定义
date: 2018-09-14 03:55:13
categories: C语言编程
toc: true
comments: true
---
# 第八章 大端模式和小端模式与宏



### 了解什么是大小端

我们知道C语言中char存储是1个字节，int是4个字节。但是在计算机中，我们每个地址单元都对应一个字节。那这个时候就有一个多个字节如何存储的问题。



### 高数据位-低数据位-高地址位-低地址位

高数据位，低数据位：0000 0000 0001 0011。左是高数据位，右是低数据位。
高地址位，低地址位：比如一个四字节内存0x10 0x20 0x30 0x40。左是低地址位，右是高地址位。



### 大小端

大小端其实就是系统对数据在内存中的存储规则。因此我们的数据分为两种方式存储。
大端模式（Big-endian）存储：数据的低数据位 放在 内存的高地址位。这和我们的阅读习惯一样。
小端模式（Little-endian）存储： 数据的低数据位 放在 内存的低地址位。

作用：在两个机器A和机器B如果要进行通信的话，那么我们就必须保证它们的存储方式是一致的。这个时候如果不一致的话就要进行转换。<strong>这里是按字节反转，而不是按位反转。</strong>



### 测试大小端

那接下来我们就进行测试，如何测试呢？那就是打印每个字节呗，这时候我们就想到了union了，里面的每一个变量的地址是一样的。
```c
int main(void)
{
    // 测试大端存储和小端存储。
    // 思路：测试第一个字节的值.使用联合体

    union MyUnion
    {
        int i;
        char ch;
    } u = {0x123456};

    printf("%x\n", u.ch); // 结果：56 // 说明该系统采用的小端存储。 x86
```

分析：int是四个字节，当转为char的时候就会舍弃三个字节，那么这个时候我们就可以看到低地址位的数据到底是什么。结果是56,说明了我们的低地址位存储的是低数据位。

目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。

其实我们不用union也可以测试，原理也是通上面分析的一样,通过类型的转换打印出首地址。当一个字节存储的时候就没有大小端的说法了。
```c
int i = 0x123456;
char ch = i;
printf("%x\n", ch);
```



### 大端模式和小端模式的交换

转换的思想就是前后交换，那首先我们看下代码。
```c
#define uint32 unsigned int
#define Tranverse32(X) ((((uint32)(X) &amp; 0xff000000) >> 24) | \
                          (((uint32)(X) &amp; 0x00ff0000) >> 8) | \
                          (((uint32)(X) &amp; 0x0000ff00) << 8) | \
                          (((uint32)(X) &amp; 0x000000ff) << 24))
测试
    uint32 i = 0x123456; 
    i = Tranverse32(i);
    printf("%x\n", i); // 结果563412
```

解释：这里测试的4个字节的存储，也就是32位。从结果来看，说明已经交换了。<strong>注意是按字节反转，而不是得到0x65432100</strong>。需要注意的是，我们这里使用的宏定义，那变量需要括起来，然后整体再需要括起来，所以每个括号都是有意义的。

那开始分析，这其实不难理解，主要是写的时候注意宏的要点，下面会介绍宏。(uint32)(X) &amp; 0xff000000)得到的就是第一个字节的值，然后移24位就是变成了
<strong>0x000000第一个字节</strong>，以此类推。这里主要是使用&amp;来得到每个字节的值然后再通过位移符号，最后通过|符号合并。



### 预处理

和其他高级语言不同的一点，C语言具有预处理和使用预处理的功能。
预处理程序，比如：宏定义，条件编译等。
作用：预处理功能便于程序的修改，阅读，移植和调试。也便于实现模块化程序设计。



### 宏

宏定义指令#define用于定义一个标识符替换一串字符(可以是常数，表达式，你可以大胆测试)，编译器遇到时自动替换。
<strong>作用：单纯的替换</strong>
使用的地方： 多次使用的东西。增加代码的扩展性。
注意：只替换一行的东西，多行需要加"&#92;"，它不同于定于变量，不需要分配空间。
示例：
```c
#define DEF_NOE 1; // 预编译期  编译器
#define DEF_INT int; //   预编译期时候， 单纯的替换
```

深入理解宏是单纯替换的，测试
```c
#define DEF_ADD(x,y) x+y;
int a = DEF_ADD(3, 3);// 区别函数原型，没有类型

#define DEF_MUL(x,y) x*y;
int b = DEF_MUL(3+2, 3+4);// 13    3+2*3+4 = 13
更加证明是单纯的替换。 因此需要给参数加括号，整体加一个括号，#define DEF_MUL(x,y) （(x)*(y));
```

<strong>需要给参数加括号，整体加一个括号</strong>



### #include指令

这在我们写程序的时候第一行就是写这个，作用是用来将另一个源文件的内容全部引进来，就是替换。因为我们的程序不可能都写在一个源文件中，要进行模块化的话就需要多个文件分类了。

#include指令经常用来包含的是我们的头文件，也就是形如".h"的文件。所以在这里你应该对下面的代码有了很了更多的理解。
```c
#include <stdio.h>
#include <stdlib.h>
```



### 条件编译

上面我们也说了宏替换，也就是单纯的替换。但是有个要注意的问题，那就是如果我们在包含另一个文件的时候，如果重复包含会怎么样？那当然就会重复定义了。所以有了条件编译，防止我们多次包含的时候出错。常用的有下面几种:
```c
#if
#engif

#ifdef
#ifndef
#endif

#undef
```

#pragma:设定编译器的状态，或者指示编译器完成一些特定的动作。