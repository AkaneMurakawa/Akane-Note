---
title: C语言编程-指针的大小和堆栈和堆
date: 2018-09-09 05:55:13
categories: C语言编程
toc: true
comments: true
---
# 第四章-指针的大小和堆栈和栈



### 指针的大小研究

32为系统最大支持4字节指针，64为系统最大支持8字节指针
Q:程序的位数是由什么决定的？
A:指针也就是我们的地址，这个由开发环境(编译器)决定，区别于基本数据类型的存储大小。<strong>你想一个是要表示我们的数据大小，而另一个是要表示我们的地址大小，或者说指针大小。</strong>我们可以测试一下。

```
//  // 32bit程序
    //  int a = 12;
    //  int *p = &amp;a;
    //  printf("%d， %d\n", sizeof(p), sizeof(int*)); // 结果：4， 4     
    //  double a1 = 12;
    //  double *p1 = &amp;a1;
    //  printf("%d, %d\n", sizeof(p1), sizeof(double*)); // 结果：4，4     
    //
    //  printf("%d, %d\n", sizeof(int(*)[1]), sizeof(int(*)[2][3])); // 结果：4，4  
```



### 栈区和堆区

在C语言中，对数据的存储是分为几块的：
```
//      栈区，以前堆栈的说法就是指内存的栈区，也叫系统栈。   堆栈 == 栈               stack overflow爆栈
    //      堆区：特点：由我们随时申请，由我们自己随时释放。实际上会限制我们使用大小，堆保留大小：默认值是1MB。虚拟内存中堆分配的大小是可以自己设置的。
    //      全局区(静态存储区)
    //      字符常量区
    //      代码区
```

我们也经常开玩笑，开完会之后Java程序员经常是直接就走了，而C程序员还要留下了打扫，说的就是对内存的管理。在Java中只不过把对内存的管理交给了GC(垃圾回收机制)来管理，如果你去研究的话，Java中也会把变量存储在不同的地方，也有堆栈，堆，静态区这种概念，原理其实也是一样的，只是一个要自己管理，一个不用我们自己管理。

栈区的空间就是由系统分配的，程序运行——>操作系统统一>调配——>程序结束——>释放资源——>如果不释放资源则其他无法使用。在运行中的多个程序之间，内存是不交叉的。



那么我们就会有一个需求，我们想自己选择释放，自己申请空间管理。
思考：如果我们申请空间，不是操作系统管理，而是自己管理(申请与释放)，那么就不会占用系统的额外资源了。

<strong>那我们就会关心我们那最多可以申请多少空间呢？这其实是由我们的编译器决定的。</strong>
```
    // 32位程序
    // int a[1000000000000000000]；
    // 错误   C2148   数组的总大小不得超过 0x7fffffff 字节。 
    // 错误   C1126   自动分配超过 2G   
    // 0x7fffffff ==  2,147,483,647字节 == 1024*1024*1024*2字节(2^31-1) == 2GB 
    //int a[INT_MAX/6]; // 理论上我们32位操作系统可申请用的的内存是4GB，但是有2GB是操作系统使用的，
                         所以理论上可以申请2GB的空间， 实际测试我们无法申请2GB的空间，因为系统也运行着其他程序，每一个程序都占用一定的内存空间。
    //printf("%d", INT_MAX);
```



<strong>但是要注意的是：必须是连续的一段空间，如果有10字节的连续空间，但是要申请连续20字节的连续空间是申请不到的。</strong>
当我们申请为空或者申请的空间不够怎么办，这个时候就要注意了。
malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. 
To return a pointer to a type other than void, use a type cast on the return value。

因此我们申请空间使用之前需要判断是否为空再继续执行下面代码，如果都申请不成功我们就无法使用了。这也是我们经常看到别人代码这样写的原因。
```
if (NULL == p2)
    {
    }
```

<strong>如果不使用了则应当释放掉</strong>
解释：释放之后就恢复初始值了
```
    //int* p = (int*)malloc(4);
    //*p = 12;
    //printf("%d, %p\n", *p, p);
    //free(p);
    //p = NULL;
    //printf("测试:%d, %p\n", *p, p); // 没有具体指向的指针，叫做野指针，这个东西不能直接使用，没有访问权限。因此这里是不会打印的
    // 野指针： 没有具体指向的指针。比如未初始化的指针，free掉的。
```

释放的时候一定是释放头指针。不能重复释放同一块空间。 释放之后就没有访问权限了。不能释放栈区空间(栈区间是由操作系统控制的)。



### malloc和free函数

这两个函数是C语言中申请内存空间和释放的函数。
内存的分配和释放: malloc free
malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void&#42;类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。void&#42; 类型表示未确定类型的指针。C,C++规定，void&#42; 类型可以通过类型转换强制转换为任何其它类型的指针。一般需和free函数配对使用。

malloc功能：在堆区申请指定大小的连续的一段空间，并返回该空间的首地址。
注意：必须是连续的一段空间，如果有10字节的连续空间，但是要申请连续20字节的连续空间是申请不到的。

<strong>Q:为什么malloc需要强制转换？</strong>
A：因为在malloc默认的是返回void&#42;。返回的其实都是内存区域的首地址，这个时候如果不进行强制类型转换的话，就不知道这个区域存储的到底是什么类型。



### 编译环境决定了数据类型的存储方式

```
// void *malloc( size_t size); 参数是无符号类型

    // size_t类型的解释：size_t (unsigned __int64 or unsigned integer, depending on the target platform)
    // 32编译器环境：unsigned int 4字节。 64编译环境： long unsigned int 8字节。

    // Definitions of common types
    #ifdef _WIN64
        typedef unsigned __int64 size_t;
        typedef __int64          ptrdiff_t;
        typedef __int64          intptr_t;
    #else
    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
    //printf("%d\n", sizeof(size_t)); // x64: 8    x86: 4
```



### (2&#42;1024&#42;1024&#42;1024 - 1)问题

```
    // warning C4307: “-”: 整型常量溢出
    解释：这种做法看似没问题，其实问题大了，我们知道int的最大范围是2^31-1。但是在2*1024*1024*1024时候就已经溢出了，然后再-就是用溢出的数去减一个数。
    //  // 解决思路：用无符号的int代替有符号的int。 2u*1024u*1024u*1024u
    //  int* p2 = (int*)malloc(2u * 1024u * 1024u * 1024u); // 无法读取内存 0xcccccccc {???},说明无法申请那么多
```



### 申请数组空间

```
    // 申请一维数组
    //  //int (*p)[5] = (int(*)[5])malloc(sizeof(int)*5);    // int(*)[5]类型
    //  //int a[5];
    //  //int (*p1)[5] = &amp;a;
    //
    //  //for (int i = 0; i < 5; i++)
    //  //{
    //  //  (*p)[i] = i;
    //  //}
    //  //for (int i = 0; i < 5; i++)
    //  //{
    //  //  printf("%d\n", (*p)[i]);
    //  //}
    //  //free(p);
    //
    //    // 申请二维数组
    //  int (*p)[2][3] = (int(*)[2][3])malloc(sizeof(int)*5);    // int(*)[5]类型
    //
    //  for (int i = 0; i < 2; i++)
    //  {
    //      for (int j = 0; j < 3; j++)
    //      {
    //          (*p)[i][j] = i+j;
    //      }
    //  }
    //
    //  for (int i = 0; i < 2; i++)
    //  {
    //      for (int j = 0; j < 3; j++)
    //      {
    //          printf("%d\t", (*p)[i][j]); // (*p)[i][j] ==  *(*(*p+i)+j)   *(p+n) = p[n]
    //      }
    //      printf("\n");
    //  }
    //
    //  free(p);
```



### calloc函数

```
    //  //void *calloc(
    //  //  size_t num, // 元素的数目
    //  //  size_t size // 每个元素字节长度。
    //  //);
    //  // calloc 函数分配数组的 num 元素，每个存储区长度 size 字节。 每个元素初始化为 0
    //  // clear allocation。动态内存分配并清零
    //
    //  // 与malloc的区别：
    //  //      calloc在动态分配完内存后，自动初始化该内存空间为零，
    //  //      而malloc不初始化，里边数据是随机的垃圾数据。
    //
    //  int* p = (int*)calloc(5, 4);
    //  for (int i = 0; i < 5; i++)
    //  {
    //      printf("%d\t", p[i]);
    //  }
    //  // 结果： 0 0 0 0 0
```

<strong>malloc和calloc的区别</strong>
1. calloc申请数组合适，初始化为0方便。
2.但是其他数据结构，比如链表，树，图，一次申请sizeof(节点)，这些用malloc更合适
3.calloc会初始化内存，所以申请的内存数很多的时候，效率会低一点点，有些事不需要初始化的。当然效率问题微乎其微



### realloc

realloc 返回一void指针用来重分配的 (可能移动）内存块。



### 跨函数使用内存

在我们的函数里，如果是局部变量，函数调用完就没有了。这个时候如果你希望把一个变量通过一个函数指向一个合法的地址是不行的。但是如果是通过malloc函数我们动态申请分配就可以了。