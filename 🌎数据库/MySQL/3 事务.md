# 3 事务

## 数据库ACID

原子性、一致性、隔离性、持久性

- 原子性：事务中的所有操作,要么全部成功,要么全部不做
- 一致性：在事务开始与结束时,数据库处于一致状态.
- 隔离性：事务如同只有这一个操作在被数据库所执行一样.
- 持久性：在事务结束时,此操作将不可逆转



## 脏读、幻读、可重复读

脏读：读到别人**未提交**的数据

不可重复读：两次读的数据不一样，读的时候别人后面**修改**了一条数据

幻读：两次读的数据不一样，读的时候别人后面又**插入**了一条数据 (MySQL增加了间隙锁解决幻读问题)



## 分布式事务

难点：原子性(跨多个不同节点)、一致性(网络传输或节点故障)、隔离性(提交不同步，读写冲突和写写冲突，容易脏读)



### 解决理论

#### CAP理论

- 一致性- Consistency
- 可用性- Availability
- 分区容错性- Partition Tolerance



#### BASE理论

CAP理论延伸：BASE理论(基本可用，软状态，最终一致性)  宕机后补偿机制



### 实现思想

整个事务切分为两个子事务

充分利用消息队列的持久化和保证送达特性

使用消息应用表，支持等幂操作

注：等幂操作-一次操作和多次操作是相同的结果



**2PC两阶段**

**3PC三阶段**

引入超时机制 canCommit、preCommit

TCC try confirm cancel



### 基于消息的最终一致性方案

消息一致性方案是通过消息中间件保证上、下游应用数据操作的[一致性](https://segmentfault.com/a/1190000011479826)。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。



上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。

那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——**答案就是超时询问机制**



## 参考

分布式事务框架tcc-transaction https://blog.csdn.net/qq_31922571/article/details/84891216

 数据库事务隔离级别-- 脏读、幻读、不可重复读（清晰解释）https://blog.csdn.net/JIESA/article/details/51317164