# 事务和锁



## 事务

事务是由一组SQL语句组成的逻辑处理单元，事务具有4个属性，通常称为事务的ACID属性。



### 事务的特性 - ACID

> 一致性是事务的最终目的，而原子性、隔离性、持久性其实都是为了实现一致性的手段”。

https://juejin.im/post/6844904040728363015#heading-4

理解事务的特性ACID， 原子性、一致性、隔离性、持久性

- 原子性（Actomicity：事务中的所有操作，**要么全部成功，要么全部不做**
- 一致性（Consistent）：事务成功提交整体数据修改，事务错误则回滚到数据回到原来的状态；**不能只提交一部分，要保持数据的一致性。**
- 隔离性（Isolation）：**事务的并发控制机制**。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。
- 持久性（Durable）：一旦事务成功提交后，只要修改的数据都会进行持久化**，不会因为异常、宕机而造成数据错误或丢失。**

在MySQL中，用undolog实现原子性，redolg实现持久性，锁实现隔离性。



### 隔离级别

- 读未提交（READ_UNCOMMITTED）：该隔离级别表示一个事务可以**读取另一个事务修改但还没有提交**的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。
- 读可提交（READ_COMMITTED）：该隔离级别表示一个事务**只能读取另一个事务已经提交**的数据。该级别可以**防止脏读**，这也是大多数情况下的推荐值。
- 可重复读（REPEATABLE_READ）：该隔离级别表示一个事务在整个过程中可以**多次重复执行某个查询，并且每次返回的记录都相同**。在事务开始后，别人修改数据提交的事务读不到。**该级别可以防止脏读和不可重复读。**
- 序列化（SERIALIZABLE）：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，**串行化，同时只能有一个事务在进行。该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



### 脏读、幻读、可重复读

在并发事务时，数据库提供了不同的隔离级别处理。数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大。不同的隔离级别会带来一些问题。



**脏读（Dirty read）**： 读到别人未提交的数据

当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。



**不可重复读（Unrepeatableread）**：指在⼀个事务内多次读同⼀数据。在这个事务还没有结束时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改（**update**）导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不⼀样的情况，因此称为不可重复读。



**幻读（Phantom read**）**:**  幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接着另⼀个并发事务（T2）插⼊（**insert**）了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。



<p style="color:red;">不可重复读和幻读区别：</p>

- 不可重复读的重点是修改（**update**），⽐如多次读取⼀条记录发现其中某些列的值被修改。**对于不可重复读, 只需要锁住满足条件的记录**
- 幻读的重点在于新增或者删除（**insert或delete**），⽐如多次读取⼀条记录发现记录增多或减少了，就**好像发⽣了幻觉**⼀样。**对于幻读,，要锁住满足条件及其相近的记录** (MySQL增加了间隙锁解决幻读问题)

我在网上看到一个有趣的解释

>不可重复读：
>比如中午去食堂吃饭，你好不容易找到了一个位置，丢下一本课本占位，接着去打饭(你认为会带回这个位置还是你的)，可是回来的时候你发现你占座的位置被人给坐了。
>
>幻读：
>你找了一个没人的角落坐下，起身去打饭，准备回来独享清闲，可是回来看见旁边坐了一个恐龙妹，严重干扰你的食欲。



脏读、不可重复读、幻读都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。**MySQL默认的隔离级别是REPEATABLE-READ**

|                  | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| read uncommitted |  √   |     √      |  √   |
|  read committed  |      |     √      |  √   |
| repeatable read  |      |            |  √   |
|   serializable   |      |            |      |



## 锁

**锁是计算机协调多个进程或线程并发访问某一资源的机制。**在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的**存储引擎**支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是**表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。** 

- **表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 
- **行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。 



### MyISAM表锁

MySQL的表级锁有两种模式：**表共享读锁（Table Read Lock）**和**表独占写锁（Table Write Lock）**。  

对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！ 

建表语句：

```sql
CREATE TABLE `mylock` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `NAME` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO `mylock` (`id`, `NAME`) VALUES ('1', 'a');
INSERT INTO `mylock` (`id`, `NAME`) VALUES ('2', 'b');
INSERT INTO `mylock` (`id`, `NAME`) VALUES ('3', 'c');
INSERT INTO `mylock` (`id`, `NAME`) VALUES ('4', 'd');
```



#### MyISAM写锁阻塞读的案例

当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。**其他线程的读写操作都会等待**，直到锁释放为止。

- sessionA：占有写锁，可进行更新
- sessionB：读，会等待锁释放



|                           session1                           |                         session2                          |
| :----------------------------------------------------------: | :-------------------------------------------------------: |
|       获取表的write锁定<br />lock table mylock write;        |                                                           |
| 当前session对表的查询，插入，更新操作都可以执行<br />select * from mylock;<br />insert into mylock values(5,'e'); | 当前session对表的查询会被阻塞<br />select * from mylock； |
|                释放锁：<br />unlock tables；                 |          当前session能够立刻执行，并返回对应结果          |



#### MyISAM读阻塞写的案例

一个session使用lock table给表加读锁，这个session可以锁定表中的记录，**但更新和访问其他表都会提示错误。**

同时，另一个session可以查询表中的记录，**但更新就会出现锁等待。**

- sessionA：占有读锁，更新或访问其它表会报错
- sessionB：可读，写会等待锁释放

|                           session1                           |                           session2                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|        获得表的read锁定<br />lock table mylock read;         |                                                              |
|   当前session可以查询该表记录：<br />select * from mylock;   |   当前session可以查询该表记录：<br />select * from mylock;   |
| 当前session不能查询没有锁定的表<br />select * from person<br />Table 'person' was not locked with LOCK TABLES | 当前session可以查询或者更新未锁定的表<br />select * from mylock<br />insert into person values(1,'zhangsan'); |
| 当前session插入或者更新表会提示错误<br />insert into mylock values(6,'f')<br />Table 'mylock' was locked with a READ lock and can't be updated<br />update mylock set name='aa' where id = 1;<br />Table 'mylock' was locked with a READ lock and can't be updated | 当前session插入数据会等待获得锁<br />insert into mylock values(6,'f'); |
|                  释放锁<br />unlock tables;                  |                       获得锁，更新成功                       |



#### 注意

MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。



#### MyISAM的并发插入问题

MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行

|                           session1                           |                           session2                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|   获取表的read local锁定<br />lock table mylock read local   |                                                              |
| 当前session不能对表进行更新或者插入操作<br />insert into mylock values(6,'f')<br />Table 'mylock' was locked with a READ lock and can't be updated<br />update mylock set name='aa' where id = 1;<br />Table 'mylock' was locked with a READ lock and can't be updated |    其他session可以查询该表的记录<br />select* from mylock    |
| 当前session不能查询没有锁定的表<br />select * from person<br />Table 'person' was not locked with LOCK TABLES | 其他session可以进行插入操作，但是更新会阻塞<br />update mylock set name = 'aa' where id = 1; |
|          当前session不能访问其他session插入的记录；          |                                                              |
|                  释放锁资源：unlock tables                   |               当前session获取锁，更新操作完成                |
|           当前session可以查看其他session插入的记录           |                                                              |

 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： 

```sql
mysql> show status like 'table%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Table_locks_immediate | 352   |
| Table_locks_waited    | 2     |
+-----------------------+-------+
-- 如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。
```



### InnoDB锁

可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： 

```sql
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 18702 |
| Innodb_row_lock_time_avg      | 18702 |
| Innodb_row_lock_time_max      | 18702 |
| Innodb_row_lock_waits         | 1     |
+-------------------------------+-------+
-- 如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高
```



#### 锁的分类

- 共享锁 Share Locks（简称S锁，属于行锁）
- 排他锁 Exclusive Locks（简称X锁，属于行锁）
- 意向共享锁 Intention Share Locks （简称IS锁，属于表锁）
- 意向排他锁 Intention Exclusive Locks （简称IX锁，属于表锁）
- 自增锁 AUTO-INC Locks



#### 共享锁（S锁）

介绍：**共享锁又称读锁**，加共享锁可以使用select … lock in share mode语句

简单来说：共享锁就是多个事务对于同一个数据，可以共享一把锁，都能访问数据库，但是只能读不能修改。

复杂来说：共享锁就是允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。



共享锁测试，多个事务对于同一个数据，可以共享一把锁，都能访问数据库，但是只能读不能修改。读会进行锁等待。

```mysql
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `NAME` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `student` (`id`, `NAME`) VALUES ('1', 'a');
INSERT INTO `student` (`id`, `NAME`) VALUES ('2', 'b');
INSERT INTO `student` (`id`, `NAME`) VALUES ('3', 'c');
INSERT INTO `student` (`id`, `NAME`) VALUES ('4', 'd');
```

|                       session1                        | session2                                                  |
| :---------------------------------------------------: | --------------------------------------------------------- |
|                   set autocommit=0;                   | set autocommit=0;                                         |
| select * from student where id =1 lock in share mode; |                                                           |
|                                                       | 可读<br />select * from student where id =1;              |
|                                                       | 进行锁等待<br />update student set name='aa' where id =1; |
|         commit;<br />释放锁，session2修改成功         |                                                           |



#### 排他锁（X锁）

介绍：**排他锁又称写锁**，加排他锁可以使用select …for update语句。**update、delete、insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型**。for update有些人也称之为MySQL的悲观锁。

简单来说：排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其它事务就不能获取该行的锁，只有当前获取了排他锁的事务可以对数据进行读取和修改。

复杂来说：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。



**因此加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。** 



排他锁测试，排他锁不能与其他锁并存，如果没有排他锁的事务对数据行加锁会进行锁等待。

```mysql
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `NAME` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `student` (`id`, `NAME`) VALUES ('1', 'a');
INSERT INTO `student` (`id`, `NAME`) VALUES ('2', 'b');
INSERT INTO `student` (`id`, `NAME`) VALUES ('3', 'c');
INSERT INTO `student` (`id`, `NAME`) VALUES ('4', 'd');
```

|                           session1                           | session2                                                     |
| :----------------------------------------------------------: | ------------------------------------------------------------ |
|                      set autocommit=0;                       | set autocommit=0;                                            |
|        select * from student where id =1 for update;         |                                                              |
|                                                              | 简单的select不会任何锁，可读<br />select * from student where id =1; |
|                                                              | 排他锁不能与其他锁并存，进行锁等待<br />select * from student where id =1 for update;<br />select * from student where id =1 lock in share mode;<br /> |
|                                                              | 排他锁不能与其他锁并存，update会加排他锁，进行锁等待<br />update student set name='aa' where id =1; |
| update student set name='aa' where id =1;<br />只有拥有排他锁才能进行修改 |                                                              |
|                                                              | select * from student where id =1;<br />RR隔离级别，可重复读，不会读取到session1修改的数据 |
|                           commit;                            | commit;                                                      |



#### 意向共享锁 （IS锁）和意向排他锁 （IX锁）

- 意向共享锁 Intention Share Locks （简称IS锁，属于表锁）：表示事务准备给数据行加入共享锁（S锁），也就是说一个数据行在加共享锁之前必须先获取该表的的意向共享锁 （IS锁）。
- 意向排他锁 Intention Exclusive Locks （简称IX锁，属于表锁）：表示事务准备给数据行加入排他锁（X锁），也就是说一个数据行在加共享锁之前必须先获取该表的的意向排他锁 （IX锁）。

注意：意向锁是InnoDB数据操作之前自动加的，不需要用户干预。



#### 自增锁

针对自增列自增长一个特殊的**表级别锁**

```mysql
show variables like 'innodb_autoinc_lock_mode';
-- 默认值是1，代表连续
```

如果事务未提交，但是依然会自增，则id永久丢失

```mysql

drop table if exists auto_test;
CREATE TABLE `auto_test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `NAME` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `auto_test` (`id`, `NAME`) VALUES ('1', 'a');
show create table auto_test\G

begin;
INSERT INTO `auto_test` (`id`, `NAME`) VALUES ('2', 'b');
rollback;
-- 事务进行了回滚，但是自增ID依然自增了，AUTO_INCREMENT=3
show create table auto_test\G


select * from auto_test;
```



#### InnoDB的行锁模式

InnoDB的行锁模式共分为两种

- 共享锁（s）
- 排他锁（x）



#### InnoDB行锁实现方式

InnoDB行锁是**通过给索引上的索引项加锁**来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。

InnoDB这种行锁实现特点意味着：

<p style="color:red;">只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p> 



**1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁**

```sql
create table tab_no_index(id int,name varchar(10)) engine=innodb;
insert into tab_no_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');
```

|                           session1                           |                           session2                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| set autocommit=0；<br />select * from tab_no_index where id = 1; | set autocommit=0；<br />select * from tab_no_index where id =2； |
|      select * from tab_no_index where id = 1 for update      |                                                              |
|                                                              |     select * from tab_no_index where id = 2 for update;      |

session2结果：ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

分析：session1只给一行加了排他锁，但是session2在请求其他行的排他锁的时候，会出现锁等待。**原因是在没有索引的情况下，innodb只能使用表锁。**



**2、创建带索引的表进行条件查询，innodb使用的是行锁**

```sql
create table tab_with_index(id int,name varchar(10)) engine=innodb;
alter table tab_with_index add index id(id);
insert into tab_with_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');
```

|                           session1                           |                           session2                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| set autocommit=0<br />select * from tab_with_indexwhere id = 1; | set autocommit=0<br />select * from tab_with_indexwhere id =2 |
|    select * from tab_with_index where id = 1 for update;     |                                                              |
|                                                              |    select * from tab_with_index where id = 2 for update;     |



**3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的**

```sql
alter table tab_with_index drop index id;
insert into tab_with_index  values(1,'4');
```

|                           session1                           |                           session2                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                       set autocommit=0                       |                       set autocommit=0                       |
| select * from tab_with_index where id = 1 and name='1' for update; |                                                              |
|                                                              | select * from tab_with_index where id = 1 and name='4' for update;<br />虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁 |



### 总结

**对于MyISAM的表锁，主要讨论了以下几点：** 
（1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。  
（2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。 
（3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。 
（4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。



**对于InnoDB表，本文主要讨论了以下几项内容：** 
（1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。 
（2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。

在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：

- 尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
- 选择合理的事务大小，小事务发生锁冲突的几率也更小；
- 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
- 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；
- 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；
- 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。



## 死锁

示例：

```sql
drop table if exists dead_lock;
create table dead_lock(id int,name varchar(10)) engine=innodb;
alter table dead_lock add index id(id);
insert into dead_lock values(1,'1'),(2,'2'),(3,'3'),(4,'4');
```

|                     session1                     |                     session2                     |
| :----------------------------------------------: | :----------------------------------------------: |
|                set autocommit=0;                 |                set autocommit=0;                 |
| select * from dead_lock where id = 1 for update; |                                                  |
|                                                  | select * from dead_lock where id = 2 for update; |
| select * from dead_lock where id = 2 for update; |                                                  |
|                                                  | select * from dead_lock where id = 1 for update; |

session2结果：ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction



MySQL 行级锁、间隙锁gapLock 解决：用主键id删除



### 打印死锁日志

有时候，生产出现死锁问题，我们很想知道是哪里发生了死锁，便可以在处理的时候进行异常捕获，然后自定义日志记录。

MySQL

```mysql
show engine innodb status;
```



Java

```java
// catch异常
catch (org.springframework.dao.DeadlockLoserDataAccessException e) {
    // 日志获取 见下方Dao
    
    // 日志打印
    log.error("业务单号{}出现死锁：type:{},name:{},status:{}", refNo,map.get("Type"), map.get("Name"),map.get("Status").split("LATEST DETECTED DEADLOCK")[1].split("FILE I/O")[0]);
}

// Dao层，死锁记录获取
@Select("show engine innodb status")
Map<String,String> getCurrentDeadLockLog();
```













间隙锁 gap lock

next-key lock

for update 

lock in share mode

mvcc







## 分布式事务

难点：原子性(跨多个不同节点)、一致性(网络传输或节点故障)、隔离性(提交不同步，读写冲突和写写冲突，容易脏读)



### 解决理论

#### CAP理论

- 一致性- Consistency
- 可用性- Availability
- 分区容错性- Partition Tolerance



#### BASE理论

CAP理论延伸：BASE理论(基本可用，软状态，最终一致性)  宕机后补偿机制



### 实现思想

整个事务切分为两个子事务

充分利用消息队列的持久化和保证送达特性

使用消息应用表，支持等幂操作

注：等幂操作-一次操作和多次操作是相同的结果



**2PC两阶段**

**3PC三阶段**

引入超时机制 canCommit、preCommit

TCC try confirm cancel



### 基于消息的最终一致性方案

消息一致性方案是通过消息中间件保证上、下游应用数据操作的[一致性](https://segmentfault.com/a/1190000011479826)。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。



上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。

那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——**答案就是超时询问机制**



## 参考

分布式事务框架tcc-transaction https://blog.csdn.net/qq_31922571/article/details/84891216

 数据库事务隔离级别-- 脏读、幻读、不可重复读（清晰解释）https://blog.csdn.net/JIESA/article/details/51317164