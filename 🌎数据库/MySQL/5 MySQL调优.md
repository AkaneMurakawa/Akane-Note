# MySQL调优

说明MySQL调优并不仅仅本篇文章的内容，对于【MySQL数据库设计规范】其实也是对MySQL的一种调优。



## 查询慢的原因

- 网络
- CPU
- IO
- 上下文切换
- 系统调用
- 生成统计信息
- 锁等待时间



## SQL优化

1. 尽量避免null，数据库中null不等于null，并且对于存在索引的地方也有很复杂。因此建议最后设计为非null
2. 合理使用范式和反范式，适当冗余
3. 不要查询不需要的数据，优化方式：加limit
4. 不需要的字段不要查出来，尤其是多表关联时候，把select *会影响性能
5. **更新频繁**（删除或更新可能造成页分裂和页合并），区分度不高的，不宜建索引
6. 使用函数不会走索引
7. 区分度高的放最前面，最左前缀原则
8. 如果明确知道只有一条结果返回，limit能够提高效率（减少判断）
9. 推荐使用代理主键，自然主键与业务耦合，不适合维护
10. 有时候，groupby或orderby的结果是一样时，groupby或orderby的字段越少越好。确保任何的groupby和order by中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程。（因为索引本身就是有序的）
11. 减少数据库访问次数（如增加缓存，单个查询改为批量查询，但需要注意的是，批量查询注意分批，一次性数据太多可能会导致查询不出来）
12. 尽量用表关联来代替子查询
13. 优化union。除非确实需要服务器消除重复的行，否则一定要使用union all，因此没有all关键字，mysql会在查询的时候给临时表加上distinct的关键字，这个操作的代价很高



## MySQL优化器优化

1.  重新定义关联表的顺序
2. 将外连接转化成内连接，**内连接的效率要高于外连接**
3. 使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式
4. 优化count(),min(),max()。索引和列是否可以为空通常可以帮助mysql优化这类表达式：例如，要找到某一列的最小值，只需要查询索引的最左端的记录即可，不需要全文扫描比较。
5. 预估并转化为常数表达式（conf），当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理
6. 索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，**可以使用覆盖索引**
7. 子查询优化。MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问，例如将经常查询的数据放入到缓存中
8. 等值传播。如果两个列的值通过等式关联，那么MySQL能够把其中一个列的where条件传递到另一个上。（了解即可，这个其实就是当我们join表的时候，如果join的字段是一个条件，那也会传到另一个表。如：using(id) where a.id > 1,  等价于using(id) where a.id > 1 **and b.id > 1**）



## 优化器的优化策略

### 静态优化

直接对解析树进行分析，并完成优化

### 动态优化

动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关mysql对查询的静态优化只需要一次，但对动态优化在每次执行时都需要重新评估



## 排序优化

无论如何排序都是一个成本很高的操作，所以从性能的角度出发，应该尽可能避免排序或者尽可能避免对大量数据进行排序。

推荐使用利用索引进行排序，但是当不能使用索引的时候，mysql就需要自己进行排序，如果**数据量小则在内存中**进行，如果**数据量大就需要使用磁盘**，mysql中称之为**filesort**。

如果需要排序的数据量小于**排序缓冲区(show variables like '%sort_buffer_size%';),**mysql使用内存进行快速排序操作，如果内存不够排序，那么mysql就会先将树分块，对每个独立的块使用快速排序进行排序，并将各个块的排序结果存放再磁盘上，然后将各个排好序的块进行合并，最后返回排序结果

```mysql
mysql> show variables like '%sort_buffer_size%';
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| innodb_sort_buffer_size | 1048576 |
| myisam_sort_buffer_size | 2097152 |
| sort_buffer_size        | 2097152 |
+-------------------------+---------+
3 rows in set (0.06 sec)
```



### 两次传输排序

介绍：**需要字段先排序，第二次查**

第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。

这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高

两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作



### 单次传输排序

介绍：**先查再排序**

先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果，此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据



### 总结

当需要排序的列的总大小超过**max_length_for_sort_data**定义的字节，mysql会选择双次排序，反之使用单次排序，当然，用户可以设置此参数的值来选择排序的方式





## 开启慢查询日志

查询系统当前慢查询配置

```mysql
SHOW VARIABLES LIKE 'slow_query%';

SHOW VARIABLES LIKE 'long_query_time';

set global slow_query_log = on;
```



在MySQL配置文件中，新增以下配置（注：修改完配置重启即可生效）

```
slow_query_log= 1 # 慢查询开启状态
slow_query_log_file= /usr/local/mysql/data/slow-query.log # 慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）
long_query_time=10 # 查询超过多少秒才记录
```



测试

```mysql
mysql> select sleep(11);
```

如果是windows，文件默认是C:\ProgramData\MySQL\MySQL Server 5.7\Data，我们可以打开文件看一下内容，可以看到能够知道查询的用户，查询时间，SQL内容等信息。

```log
# Time: 2020-10-22T03:40:23.463303Z
# User@Host: root[root] @ localhost [::1]  Id:     8
# Query_time: 11.017508  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0
use test;
SET timestamp=1603338023;
select sleep(11);
```



## 大表优化

- 限定范围
- 读写分离
- 分库分表

分表：垂直分区、水平分区（谨慎水平分区，会使业务变复杂，除非适合场景，如按年分区、按季分区。可考虑分库）