# 面试题



## Redis是单线程的？

Redis是基于内存的。主要是单线程的，然而有些操作，例如UNLINK、 slow I/O处理或其他的时候，需要开始额外的线程(用于实现非阻塞)，具体原因请阅读`redis.conf`中的`THREADED I/O`模块。



## 为什么Redis那么快？

Redis是基于**内存**的，CPU并不是Redis性能瓶颈，Redis的瓶颈是机器的内存和网络带宽。因为是单线程(没有CPU上下文切换)，读写都在一个CPU上，导致Redis非常的快。



## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了**相同的过期时间**，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。



解决方法：

将缓存失效时间分散，例如：在原有基础上加上随机值



## 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。



解决方法：

有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。



其他方法：

1. 增强校验

2. 布隆过滤器Bloom Filter

> 布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。



缺点：

1. 存在误判
2. 删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter



实现：Guava中的Bloom Filter



## 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，如果缓存失效了，就会直接访问数据库，就被击穿了。这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。



解决方法：设置热点key不过期，或加上互斥锁。



互斥锁(mutex key)实现：



简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。SETNX (SET if Not eXists)：不存在则设置，可以实现锁的效果。



## 分布式锁

场景：避免不同节点重复处理、避免数据被破坏

1. 必须设置超时时间，防止服务挂掉未释放锁
2. Redis 分布式锁不要用于较长时间的任务（如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制）



## 如何保证缓存与数据库双写时的数据⼀致性?

> ⼀般情况下我们都是这样使⽤缓存：先读缓存，缓存没有的话，就读数据库，然后取出数据后放
>
> ⼊缓存，同时返回响应。缓存和数据库双写时，就可能存在数据一致性问题。

解决思路：最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md



问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。



问题：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，**查到了修改前的旧数据**，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...

解决思路：更新数据的时候，根据**数据的唯一标识**，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。